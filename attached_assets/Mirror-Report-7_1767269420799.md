# Mirror Hunt #6: Professional Project Architecture

## Current State Assessment

The Council's current architecture is a hybrid model. It has a `features` directory, suggesting a feature-based approach, but also has `lib`, `components`, and `pages` directories at the root level, which is more typical of a file-type-based structure.

**Architecture Diagram (Current):**
```
src/
├── features/
│   ├── council/
│   │   ├── api/
│   │   ├── components/
│   │   ├── hooks/
│   │   └── store/
│   └── settings/
├── components/
│   └── primitives/
├── lib/  (very high coupling)
├── pages/
└── test/
```

**Load-Bearing Walls:**

The `grep` analysis reveals critical, highly-coupled files that act as "load-bearing walls":

-   `src/lib/types.ts`: **Imported 12 times.** Changes to this file have a high risk of causing breaking changes across the entire application.
-   `src/lib/config.ts`: **Imported 5 times.** While less coupled than `types.ts`, it still represents a central point of configuration that many features depend on.

This centralization of types and configuration is a significant architectural debt.

## Professional Patterns Found

### Pattern 1: Feature-First Architecture (bulletproof-react)

-   **Repo:** `alan2207/bulletproof-react`
-   **What to Mirror:** The strict modularity where every feature is a self-contained unit.
-   **Migration Path:**
    1.  Create a `routes` directory inside each feature folder (`src/features/council/routes`).
    2.  Move the corresponding page component (e.g., `src/pages/Index.tsx`) into that new directory.
    3.  Co-locate any types, stores, and hooks that are *only* used by that feature inside the feature folder.
    4.  Create a `src/providers` directory for app-wide context and providers.
-   **Benefit:** New features can be added (or removed) with minimal impact on the rest of the application. It dramatically improves scalability and developer velocity.

### Pattern 2: Co-location of Routes and Components (TanStack Router)

-   **Repo:** `TanStack/router`
-   **What to Mirror:** The practice of defining a route component and its related components in the same location.
-   **Migration Path:** This is complementary to the "Feature-First" pattern. As you create `routes` directories within each feature, the page component for that route becomes the natural entry point.
-   **Benefit:** It's intuitive to find the code for a specific page, as the route definition and the component tree are together.

### Pattern 3: Strict Separation of UI and Logic (shadcn-ui/taxonomy & nextjs-subscription-payments)

-   **Repo:** `shadcn-ui/taxonomy`, `vercel/nextjs-subscription-payments`
-   **What to Mirror:** A clear distinction between client components (UI), server components (logic), and shared libraries.
-   **Migration Path:**
    1.  Continue using `src/components/primitives` for truly generic, reusable UI components.
    2.  Ensure that components inside a feature folder (`src/features/council/components`) contain business logic specific to that feature.
    3.  The `src/lib` directory should be reserved for genuinely app-wide utilities (e.g., `cn`, `date-fns` wrappers), not business logic or types for a specific feature.
-   **Benefit:** Enforces separation of concerns, making the code easier to reason about and test.

## Critical Gaps

1.  **No Clear Feature Boundaries:** The `council` feature is leaking its concerns into the root `lib` and `pages` directories.
2.  **Over-Centralized Types:** The `src/lib/types.ts` file is a major bottleneck and point of fragility. A change for one feature can inadvertently break another.
3.  **Scalability Issues:**
    -   **Scenario A (New Execution Mode):** Adding a new mode would likely require modifying the central `types.ts` and `config.ts` files, plus any components that have logic based on the execution mode. This touches multiple "load-bearing" files.
    -   **Scenario B (Web Scraping Expert):** This should be a modular addition, but the current structure encourages putting the new expert's type in `types.ts`, immediately creating a dependency.
    -   **Scenario C (Template Library):** This could be a new feature folder (`src/features/templates`), but it would be tempted to share types with `council` through `lib/types.ts`, creating an unnecessary coupling between features.

## Recommended Migration

**Phase 1: Decouple Core Types (Immediate Win)**

1.  **Action:** Create a `types.ts` file inside each feature directory (`src/features/council/types.ts`).
2.  **Goal:** Move all types that are *exclusive* to the Council feature out of `src/lib/types.ts` and into the new, local file. `src/lib/types.ts` should only contain truly global types.
3.  **Benefit:** This is the highest-impact, lowest-effort change to improve modularity.

**Phase 2: Structural Refactor to "Feature-First"**

1.  **Action:** For each page in `src/pages`, move it into a `routes` sub-directory within its corresponding feature in `src/features`.
2.  **Goal:** Eliminate the top-level `pages` directory. All routes should be defined within the feature they belong to.
3.  **Benefit:** Fully aligns the project with the scalable "Feature-First" architecture.

**Phase 3: Future-Proofing with a Plugin Mindset**

1.  **Action:** Define a clear interface for "Expert Types" and "Execution Modes" in the global `lib/types.ts`.
2.  **Goal:** New experts and modes can be implemented as self-contained modules that adhere to this interface, without modifying core files. This treats new capabilities as "plugins."
3.  **Benefit:** The system becomes extensible and far more resilient to change.

## Risk Assessment

-   **Breaking Changes:** Phase 1 and 2 will cause significant breaking changes, primarily in import paths. This will require a careful and systematic refactoring effort.
-   **Time Investment:**
    -   Phase 1: **Low (2-4 hours)**. A developer can do this quickly with find-and-replace.
    -   Phase 2: **Medium (8-12 hours)**. Requires moving files and updating routing logic.
    -   Phase 3: **Low (4-6 hours)**. Primarily involves refactoring types and interfaces.
-   **Rollback Strategy:** Use Git branches. Each phase should be a separate branch that can be reverted if it introduces instability. The migration should be done incrementally, with thorough testing at each step.
