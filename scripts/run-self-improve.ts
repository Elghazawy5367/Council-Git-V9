#!/usr/bin/env tsx
/**
 * Self-Improvement Runner
 * 
 * Executes the self-improvement learning cycle and generates reports.
 */
import * as fs from "fs";
import * as path from "path";
import { learnFromSuccess } from "../src/lib/self-improve";
import type { LearningResult, SuccessPattern } from "../src/lib/self-improve";

// Parse command line arguments
function parseArgs(): {
  niche: string;
  minStars: number;
  maxRepos: number;
  githubToken?: string;
} {
  const args = process.argv.slice(2);
  const options: Record<string, string> = {};
  args.forEach(arg => {
    const [key, value] = arg.split("=");
    if (key.startsWith("--")) {
      options[key.slice(2)] = value;
    }
  });
  return {
    niche: options.niche || "developer tools",
    minStars: parseInt(options["min-stars"] || "1000"),
    maxRepos: parseInt(options["max-repos"] || "20"),
    githubToken: options["github-token"] || process.env.GITHUB_TOKEN
  };
}

// Format confidence level
function formatConfidence(confidence: number): string {
  if (confidence >= 80) return "üü¢ VERY HIGH";
  if (confidence >= 60) return "üü° HIGH";
  if (confidence >= 40) return "üü† MODERATE";
  return "üî¥ LOW";
}

// Print learning results
function printResults(result: LearningResult): void {
  // Group patterns by category
  const byCategory = result.patternsFound.reduce((acc, p) => {
    if (!acc[p.category]) acc[p.category] = [];
    acc[p.category].push(p);
    return acc;
  }, {} as Record<string, SuccessPattern[]>);

  // Print patterns by category
  Object.entries(byCategory).forEach(([category, patterns]) => {
    patterns.sort((a, b) => b.confidence - a.confidence).forEach((pattern, idx) => {});
  });

  // Print insights

  result.insights.forEach((insight, idx) => {});

  // Print recommendations

  result.recommendations.forEach((rec, idx) => {});
}

// Generate markdown report
function generateMarkdownReport(result: LearningResult, outputPath: string): void {
  let markdown = `# Self-Improvement Learning Report\n\n`;
  markdown += `**Generated:** ${new Date(result.timestamp).toLocaleString()}\n`;
  markdown += `**Niche:** ${result.niche}\n`;
  markdown += `**Repositories Analyzed:** ${result.reposAnalyzed}\n\n`;
  markdown += `## Summary\n\n`;
  markdown += `- **Patterns Discovered:** ${result.patternsFound.length}\n`;
  markdown += `- **Insights Generated:** ${result.insights.length}\n`;
  markdown += `- **Recommendations:** ${result.recommendations.length}\n\n`;

  // Group patterns
  const byCategory = result.patternsFound.reduce((acc, p) => {
    if (!acc[p.category]) acc[p.category] = [];
    acc[p.category].push(p);
    return acc;
  }, {} as Record<string, SuccessPattern[]>);

  // Write patterns by category
  Object.entries(byCategory).forEach(([category, patterns]) => {
    markdown += `## ${category.charAt(0).toUpperCase() + category.slice(1)} Patterns\n\n`;
    patterns.sort((a, b) => b.confidence - a.confidence).forEach((pattern, idx) => {
      markdown += `### ${idx + 1}. ${pattern.pattern}\n\n`;
      markdown += `**Confidence:** ${Math.round(pattern.confidence)}%\n\n`;
      markdown += `**Evidence:**\n`;
      pattern.evidence.forEach(ev => {
        markdown += `- ${ev}\n`;
      });
      markdown += `\n**Learned from:**\n`;
      pattern.learnedFrom.forEach(repo => {
        markdown += `- [${repo}](https://github.com/${repo})\n`;
      });
      markdown += `\n`;
    });
  });

  // Write insights
  markdown += `## Key Insights\n\n`;
  result.insights.forEach((insight, idx) => {
    markdown += `${idx + 1}. ${insight}\n`;
  });
  markdown += `\n`;

  // Write recommendations
  markdown += `## Actionable Recommendations\n\n`;
  result.recommendations.forEach((rec, idx) => {
    markdown += `${idx + 1}. ${rec}\n`;
  });
  markdown += `\n`;
  markdown += `---\n\n`;
  markdown += `*This report was automatically generated by the Self-Improving Council system.*\n`;
  fs.writeFileSync(outputPath, markdown);
}

// Main execution
async function main(): Promise<void> {
  const options = parseArgs();
  try {
    // Run learning
    const result = await learnFromSuccess(options.niche, {
      minStars: options.minStars,
      maxRepos: options.maxRepos,
      githubToken: options.githubToken
    });

    // Print results
    printResults(result);

    // Generate report
    const logsDir = path.join(process.cwd(), "logs");
    fs.mkdirSync(logsDir, {
      recursive: true
    });
    const reportPath = path.join(logsDir, "self-improve-report.md");
    generateMarkdownReport(result, reportPath);

    // Exit successfully
    process.exit(0);
  } catch (error) {
    console.error("\n‚ùå Learning cycle failed:", error);
    process.exit(1);
  }
}

// Run
main();